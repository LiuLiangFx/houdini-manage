# Copyright (C) 2017  Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import datetime
import json
import os
import operator
import shlex
import subprocess
from . import __version__
from .config import config


def get_houdini_environment_path(hou=None):
  hou = hou or config.get('houdinienv', 'houdini16.0')
  if not '/' in hou and not os.sep in hou:
    hou = os.path.expanduser('~/Documents/' + hou + '/houdini.env')
  return os.path.normpath(hou)


def get_houdini_user_prefs_directories():
  directory = os.path.expanduser('~/Documents')
  if not os.path.isdir(directory):
    return []
  result = []
  for name in os.listdir(directory):
    envfile = os.path.join(directory, name, 'houdini.env')
    if name.startswith('houdini') and os.path.isfile(envfile):
      result.append((name, envfile))
  result.sort(key=operator.itemgetter(0), reverse=True)
  return result


def load_library_config(directory):
  config_file = os.path.join(directory, 'houdini-library.json')
  if not os.path.isfile(config_file):
    raise NotALibraryError('missing library configuration file: {}'.format(config_file))
  with open(config_file) as fp:
    return json.load(fp)


def install_library(env, directory, overwrite=False):
  # Open the librarie's configuration file.
  config = load_library_config(directory)

  now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M')
  version = __version__

  # Initialize the default section. It's purpose is to make sure that
  # Houdini's default paths do not get messed up.
  section = env.get_named_section('DEFAULT')
  if not section:
    section = env.add_named_section('DEFAULT', '', before=env.get_first_named_section())
  else:
    section.clear()
  section.add_comment('  Automatically generated by houdini-manage v{}'.format(version))
  section.add_comment('  Last update: {}'.format(now))
  #for info in HOUDINI_PATH_ENVVARS:
  #  # Houdini will use the default value of the variable when it sees
  #  # the ampersand.
  #  section.add_variable(info['var'], '&')
  section.add_variable('HOUDINI_PATH', '&')
  section.add_variable('PYTHONPATH', '&')

  # Create or update the section for this library.
  directory = os.path.normpath(os.path.abspath(directory))
  section = env.get_named_section('library:' + config['libraryName'])
  if not section:
    previous = False
    section = env.add_named_section('library:' + config['libraryName'], '')
  else:
    previous = True
    if not overwrite:
      raise PreviousInstallationFoundError(config['libraryName'])

  section.clear()
  section.add_comment('  Automatically generated by houdini-manage v{}'.format(version))
  section.add_comment('  Last update: {}'.format(now))
  #for info in HOUDINI_PATH_ENVVARS:
  #  if not info['dir']: continue
  #  vardir = os.path.join(directory, info['dir'])
  #  if not os.path.isdir(vardir): continue
  #  section.add_variable(info['var'], '$' + info['var'], vardir)
  section.add_variable('HOUDINI_PATH', '$HOUDINI_PATH', directory)
  section.add_variable('PYTHONPATH', '$PYTHONPATH', os.path.join(directory, 'python'))
  section.add_variable('HLIBPATH_' + config['libraryName'], directory)
  section.add_variable('HLIBVERSION_' + config['libraryName'], config['libraryVersion'])
  if config.get('environment'):
    section.add_comment('Environment variables specified by the library:')
    for line in config['environment']:
      section.add_line(line)


def remove_library(env, name):
  section = env.get_library(name)
  if section:
    env.remove_section(section)
    return True
  return False


def get_houdini_application_dir():
  install_dir = config.get('houdiniapp')
  if install_dir:
    return install_dir
  if os.name == 'nt':
    import winreg
    key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, 'Houdini.hip\\shell\\open\\command')
    path = shlex.split(winreg.QueryValue(key, None))[0]
    path = os.path.dirname(os.path.dirname(path))
  else:
    path = ''
  return path


def build_dso(hou_app_dir, library_dir):
  hcustom = os.path.join(hou_app_dir, 'bin\\hcustom.exe' if os.name == 'nt' else 'bin/hcustom')
  library_dir = os.path.abspath(library_dir)
  config = load_library_config(library_dir)

  dso_source = os.path.join(library_dir, config.get('dsoSource', 'dso_source'))
  if not os.path.isdir(dso_source):
    return 0, True

  dso_dir = os.path.join(library_dir, 'dso')
  if not os.path.isdir(dso_dir):
    os.makedirs(dso_dir)

  files = []
  for name in os.listdir(dso_source):
    ext = os.path.splitext(name)[1].lower()
    if ext in ('.c', '.cc', '.cxx', '.cpp'):
      files.append(os.path.join(dso_source, name))

  if not files:
    return 0, True

  command = [hcustom]
  if config.get('dsoDebug'):
    command += '-g'
  for path in config.get('dsoInclude', []):
    command += ['-I', os.path.join(library_dir, path)]
  for path in config.get('dsoLibdir', []):
    command += ['-L', os.path.join(library_dir, path)]
  for lib in config.get('dsoLibs', []):
    command += ['-l', lib]
  command += ['-i', dso_dir]

  print('Building DSOs for "{}" ...'.format(config['libraryName']))

  ok = True
  for filename in files:
    current_command = command + [filename]
    print()
    print('  {} ...'.format(os.path.basename(filename)))
    print()
    res = subprocess.call(current_command, cwd=dso_dir)
    if res != 0:
      print('Error: hcustom failed with exit code', res)
      ok = False

  print('Done.')
  return len(files), ok


class InstallError(Exception):
  pass

class NotALibraryError(InstallError):
  pass

class PreviousInstallationFoundError(InstallError):
  def __init__(self, library_name):
    self.library_name = library_name
